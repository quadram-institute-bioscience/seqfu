#!/usr/bin/env perl
#!/usr/bin/env perl
# ABSTRACT: Concatenate FASTQ Paired-end files
# PODNAME: pe-cat

use 5.012;
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use FindBin qw($RealBin);
use lib  "$RealBin/../seqfu/", "$RealBin/seqfu/", "$RealBin/../lib/perl5",  "$RealBin/lib";

use Local::PE;
use Local::SeqFu;

my $PROGRAM = basename($0);
my $VERSION = $Local::SeqFu::VERSION;
my ($opt_force_fasta, $opt_force_fastq, $opt_upper, $opt_help, $opt_verbose, $opt_version);
my ($opt_minlen, $opt_prefix,$opt_maxlen, $opt_out_1, $opt_out_2, $opt_out_basename, $opt_strip_comments, $opt_interleaved_input, $opt_interleaved_output);
my ($opt_no_interleave);
my $opt_separator = '.';
my $opt_tag1 = '_R1';
my $opt_tag2 = '_R2';
my $opt_ext  = '.fastq';
my $opt_basename_separator = '_';
my $opt_line_size = $Local::SeqFu::fu_linesize;

if (!GetOptions(
    'p|prefix=s'            => \$opt_prefix,
    's|split-filenam=s'     => \$opt_basename_separator,
    'o|outputbasename=s'    => \$opt_out_basename,
    'o1|output-R1=s'        => \$opt_out_1,
    'o2|output-R2=s'        => \$opt_out_2,
    'tag1=s'                => \$opt_tag1,
    'tag2=s'                => \$opt_tag2,
    'ext=s'                 => \$opt_ext,
    'i|interleaved-input'   => \$opt_interleaved_input,
    'io|interleaved-output' => \$opt_interleaved_output,
    'strip-comments'        => \$opt_strip_comments,
    's|separator=s'         => \$opt_separator,
    'u|uppercase'           => \$opt_upper,
    'l|minlength=i'         => \$opt_minlen,
    'no-interleave'         => \$opt_no_interleave,
    'version'               => \$opt_version,
    'verbose'               => \$opt_verbose,
    'help'                  => \$opt_help,
)) {
        say STDERR "Wrong parameters: type $PROGRAM --help for full documentation.";
        exit 1  ;
}


$Local::SeqFu::fu_linesize  = $opt_line_size;
$Local::SeqFu::fu_verbose   = $opt_verbose;



# Print version
if ($opt_version) {
    version();
}

# Print man (help)
pod2usage({-exitval => 0, -verbose => 2}) if $opt_help;

# Read STDIN (interleave)
if (!  $ARGV[0] ) {
    usage();
    say STDERR " Reading from STDIN... [Ctrl-C to exit]";
    $opt_interleaved_input = 1;
    push(@ARGV, '{{STDIN}}');
    verbose("No files provided: assuming interleaved STDIN");
}

# Check  parameters
my $ofh1;
my $ofh2;
if ($opt_interleaved_output) {
    # INTERLEAVED OUTPUT
    if ($opt_out_1) {
      open ($ofh1, '>', "$opt_out_1") || die " FATAL ERROR: Unable to write R1 to <$opt_out_basename>\n";
    } else {
        verbose("No output file provided: assuming interleaved STDOUT");
        $ofh1 = *STDOUT;
    }
} elsif ($opt_out_basename and ($opt_out_1 or $opt_out_2) ) {
    usage();
    die " ERROR: Please specify either output basename (-o) or individual files (-o1 and -o2), not both\n";
} elsif ( ($opt_out_1 and not $opt_out_2) or (not $opt_out_1 and $opt_out_2)  ) {
   usage();
    die " ERROR: Please specify both individual files (-o1 and -o2), or add --interleaved-output.";
} elsif ($opt_out_1 and $opt_out_2) {
    open ($ofh1, '>', "$opt_out_1") || die " FATAL ERROR: Unable to write R1 to <$opt_out_1>\n";
    open ($ofh2, '>', "$opt_out_2") || die " FATAL ERROR: Unable to write R2 to <$opt_out_2>\n";
} elsif ($opt_out_basename) {
    open ($ofh1, '>', "$opt_out_basename$opt_tag1$opt_ext") || die " FATAL ERROR: Unable to write R1 to <$opt_out_basename$opt_tag1$opt_ext>\n";
    open ($ofh2, '>', "$opt_out_basename$opt_tag2$opt_ext") || die " FATAL ERROR: Unable to write R2 to <$opt_out_basename$opt_tag2$opt_ext>\n";
} else {
    usage();
    die " ERROR: Please specify either output basename (-o) or individual files (-o1 and -o2)\n";
}

my %printed_seqs = ();
my %parsed_files = ();
my $prefix = '';
# Process all the files
for my $filename (@ARGV) {
    my $counter = 0;
    # Do not attempt parsing a reverse file
    next if ($parsed_files{$filename});
    $parsed_files{$filename} = 1;

    # Scan directories for *.f* files
    if (-d "$filename") {
        verbose("Adding *.f* files from directory \"$filename\"");
        push(@ARGV, glob("$filename/*.f*"));
        next;
    }



    my $reader;
    eval {
      $reader = Local::PE->new({
            filename => "$filename",
            interleaved => $opt_interleaved_input,
        });
    };


    if ($@) {
        say STDERR " [ERROR] Ignoring $filename: error reading it.";
        next;
    }
    verbose("Parsing \"$filename\"");

    if ($opt_prefix) {
        $prefix = $opt_prefix;
        my ($basename) = split /\./,  basename($filename);
        my ($sample) = split /$opt_basename_separator/, $basename;
        $prefix =~s/%B/$basename/;
        $prefix =~s/%S/$sample/;
    }
    while (my $s = $reader->getReads() ) {
        my $name = $s->{name};

        if ($opt_minlen) {
            next if (lengt( $s->{seq1} ) < $opt_minlen);
            next if (lengt( $s->{seq2} ) < $opt_minlen);
        }
        if ($printed_seqs{ $s->{name} }) {
            $name .= $opt_separator . $printed_seqs{ $s->{name} };
        }
        $printed_seqs{ $s->{name} }++;

        my $comment1 = '';
        my $comment2 = '';
        if ($opt_upper) {
             $s->{seq1} = uc( $s->{seq1} );
             $s->{seq2} = uc( $s->{seq2} );
        }
        $comment1 = ' ' . $s->{comment1} if (defined $s->{comment1} and not $opt_strip_comments);
        $comment2 = ' ' . $s->{comment2} if (defined $s->{comment2} and not $opt_strip_comments);


        if ($opt_interleaved_output) {

            say {$ofh1} '@', $s->{name}, $comment1, "\n", $s->{seq1}, "\n+\n", $s->{qual1}, "\n",
                        '@', $s->{name}, $comment2, "\n", $s->{seq2}, "\n+\n", $s->{qual2};
        } else {

            say {$ofh1} '@', $s->{name}, $comment1, "\n", $s->{seq1}, "\n+\n", $s->{qual1};
            say {$ofh2} '@', $s->{name}, $comment2, "\n", $s->{seq2}, "\n+\n", $s->{qual2};
        }
        $counter++;

    }
    if ($reader->{error}) {
        say STDERR "[WARNING] Paired end set $filename error:\n $reader->{error}.\n $counter pairs printed.";
    }
    verbose("$filename\t$counter reads");

    $parsed_files{$reader->{rev}}++;
}



sub usage {
    my $horizontal_bar = " " . '-' x 50;
    say STDERR " $PROGRAM $VERSION";
    say STDERR " A program to concatenate sequence files";

    say STDERR $horizontal_bar;
    say STDERR " Type \`$PROGRAM --help\` to display the full manual";
}

sub version {
    say STDOUT "$PROGRAM $VERSION";
    exit;
}
__END__

=pod

=encoding UTF-8

=head1 NAME

fu-cat - concatenate FASTA or FASTQ files

=head1 SYNOPSIS

  fu-cat [options] [FILE1 FILE2 FILE3...]

=head1 DESCRIPTION

This program parses a list of FASTA/FASTQ and will concatenate them
ensuring consistent output. Will rename duplicate sequence names.
Will try to autodetect the format of all files before executing and
decide accordingly the output format (FASTA if at least one of the
files is FASTA, otherwise FASTQ). If reading from STDIN the first
sequence is in FASTQ format, will skip all the sequences without a
quality string.

If no files are provided the program will try reading from STDIN,
otherwise add a '-' to the list of files to also read from STDIN.

=head1 PARAMETERS

=over 4

=item I<-s>, I<--separator>

When a second sequence with a name that was already printed is found,
the program will append a progressive number, separated by this string.
Use `fu-rename` if you need more options.
[default: "."]

=item I<-f>, I<--fasta>

Force FASTA output

=item I<-q>, I<--fastq>

Force FASTQ output. Will B<not> print any sequence without quality
(they will be skipped)

=item I<-u>, I<--uppercase>

Will print the whole sequence in uppercase

=item I<-w>, I<--width> INT

Size of the FASTA lines. Specifing 0 will print the whole sequence in the same line (default: 0)

=item I<--verbose>

Print more details

=item I<--help>

Display this help page

=item I<--version>

Print version and exit

=back

=head1 AUTHOR

Andrea Telatin <andrea@telatin.com>

=head1 COPYRIGHT AND LICENSE

This software is Copyright (c) 2014-2020 by Andrea Telatin.

This is free software, licensed under:

The MIT (X11) License

=cut
